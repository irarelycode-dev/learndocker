docker pull
docker run <image>
docker run -p host_port:container_port <image>
docker run -d -p host_port:container_port <image>
docker run --detach -p host_port:container_port <image>
docker stop <container_id/container_name>
docker run -d -p host_port:container_port --name <container_name> <image>
docker ps or docker container ls
docker ps -a or docker container ls -a
docker logs <container_name>
docker top <container_name> //displays the running process of the container

what happens when in "docker run"
1. Looks for image locally in the cache
2. If not, looks in the remote image repository (defaults to Docker Hub)
3. download the latest version (nginx:latest by default)
4. Creates a new container based on that image and prepares to start
5. Gives it a virtual IP on a private network inside a docker engine
6. opens up a port and runs

docker image rm <image_name>
docker exec -it <image_name> sh
docker start <container_id>
docker kill <container_id>
docker stop <container_id>
docker system prune //removes all containers, all networks not used by atleast one container, all dangling images and build cache
docker images
docker container rm <container_name>
docker container inspeact <container_id> //returns a json of how the container was started.
docker container stats //returns live status of the running containers
docker container run -it //starts new container interactively
docker container exec -it //run additional command in existing container

docker exec -it ubuntu sh
# apt-get install -y curl
#curl google.com
#exit 

docker exec -it mariadb bash //this runs an additional process on an existing running container
#ps aux  //it is used to monitor processes running on a linux system



docker networks
1. each container is connected to a private virtual network called "bridge"
2.Each virtual network routes through NAT firewall on host IP
3.All containers on a virtual network can talk to each other without -p
4.Best practice is to create a new virtual network for each app


docker network ls
docker network inspect <net_name> //summary of the network. All containers running on that network.
docker run -d --name new_nginx --network my_app_net nginx
docker network create my_app_net
docker network connect <net_name> <container_name> //dynamically creates a NIC in a container on an existing virtual network
docker network disconnect <net_name> <container_name> //dynamically removes a NIC from a container

docker networks DNS
//DNS is the key to easy inter-container communication
//docker daemon has a built-in DNS server that containers use by default
docker container exec -it new_nginx ping nginx
//containers should not rely on IP addresses for communication
//DNS for friendly names is built-in if you use custom networks
//The default network bridge however does not have a DNS server by default, so you should use --link for communication
//Right, the default bridge network driver allow containers to communicate with each other when running on the same docker host.


image: image is an ordered collection of root filesystem changes and the corresponding execution parameters for 
use within a container  runtime.

Not a complete OS.No kernel,kernel modules.

docker tag <image_name> <tag_name>
//when you tag an existing image, you get the same image_id
docker history <image_name>:version

//official repositories live at the root namespace of the registry, They do not need account_name in front of
//<repo_name>

docker login
docker image push <image_name>
dcoker image tag <old_image_name> <new_image_name>
docker build -f <dockerfile> -t tag .